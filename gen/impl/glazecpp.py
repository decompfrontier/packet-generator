from schema import *
from datetime import datetime
from schema import *
from gen.data import *

class GlazeGenerator(Generator):
    def __init__(self):
        # TODO: remove state
        self.mapped_groups: dict[str, str] = {}

    def get_start_mark(self, date: datetime, file_name: str) -> str:
        return '''
/*
    THIS FILE WAS AUTOGENERATED BY packet-generator ON {}
    
    DO NOT MODIFY THIS FILE, INSTEAD, MODIFY THE FILE {} !!!
*/
#pragma once

#include <glaze_helpers.hpp>

'''.format(date.strftime("%Y-%m-%d %H:%M:%S"), file_name)
    
    def get_end_mark(self) -> str:
        return ""
    
    def _get_type_str(self, t: GeneratorField) -> str:
        if t.type_id == int:
            rt = "uint32_t"
        elif t.type_id == long:
            rt = "uint64_t"
        elif t.type_id == str:
            rt = "std::string"
        elif t.type_id == bool or t.type_id == intbool or t.type_id == strbool:
            rt = "bool"
        elif t.type_id == datetimeunix or t.type_id == datetime:
            rt = "std::chrono::system_clock::time_point"
        else:
            rt = t.type_id.__name__       
        
        if t.default_action == DefaultType.Omit:
            return "std::optional<{}>".format(rt)
        
        return rt

    def _get_field(self, clz: GeneratorField):
        '''
        std::string key{};
        '''

        if issubclass(type(clz.type_id), Enum):
            return "{} = {},".format(clz.name, clz.type_id.value)
        
        string_type = self._get_type_str(clz)
        return "{}\t{}{{}};".format(string_type, clz.name)

    def _get_field_metadata(self, f: GeneratorField) -> str:
        '''
        "Kn51uR4Y", glz::quoted<&T::key>,
        '''

        glazemt = ""

        if f.type_id == str and f.quoted:
            glazemt = "glz::quoted<&T::{}>".format(f.name)
        elif f.type_id == float:
            glazemt = "glz::write_float32<&T::{}>".format(f.name)
        elif f.type_id == intbool:
            glazemt = "glz::bools_as_numbers<&T::{}>".format(f.name)
        elif f.type_id == strbool:
            glazemt = "glz::quoted_num<glz::bools_as_numbers<&T::{}>>".format(f.name)
        elif f.type_id == datetimeunix:
            glazemt = "glz::custom<[](auto& out, uint64_t in){{ out.{} = glzhlp::read_datetimeunix(in); }}, [](auto& in) -> auto& {{ return glzhlp::write_datetimeunix(in.{}); }}>".format(f.name, f.name)
        elif f.type_id == datetime:
            glazemt = "glz::custom<[](auto& out, uint64_t in){{ out.{} = glzhlp::read_datetime(in); }}, [](auto& in) -> auto& {{ return glzhlp::write_datetime(in.{}); }}>".format(f.name, f.name)        
        else:
        #elif f.type_id == int or f.type_id == bool or f.type_id == long or f.type_id == str:
            glazemt = "&T::{}".format(f.name)
        
        glazekey = f.key

        if len(f.key) < 1:
            glazekey = self.mapped_groups[f.type_id.__name__]

        return '''\"{}\", {},'''.format(glazekey, glazemt)
    
    def _get_class_type(self, type: ClassType) -> str:
        match type:
            case ClassType.Struct:
                return "struct"
            case ClassType.Enumerator:
                return "enum class"
            case _:
                raise Exception("Unsupported class type: {}".format(str(type)))

    def _get_class(self, clz: GeneratorData, def_name: str) -> str:
        '''
        class definition:

        struct SignalKeyData {
            std::string key;
        };

        '''

        buf = '''{} {} {{
'''.format(self._get_class_type(clz.class_type), def_name)

        for field in clz.fields:
            buf = "".join((buf, "\t", self._get_field(field), "\n"))
        
        return "".join((buf, "};"))
    
    def _get_class_metadata(self, clz: GeneratorData, def_name: str):

        '''

        // Any other case
        
        template <>
        struct glz::meta<SignalKeyData>
        {
            using T = SignalKeyData;
            static constexpr auto value = object(
                "Kn51uR4Y", glz::quoted<&T::key>
            );
        };

        // ArrayStep.NoArray

        template <>
        struct glz::meta<SignalKey>
        {
            static constexpr auto value = object(
                "6FrKacq7", object (
                    "Kn51uR4Y", glz::quoted<&T::key>
                )
            )
        }
        
        '''

        if clz.class_type == ClassType.Enumerator:
            return ""

        buf = '''template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto value = object(
'''.format(def_name, def_name)

        for field in clz.fields:
            buf = "".join((buf, "\t\t", self._get_field_metadata(field), "\n"))
        
        buf = "".join(( buf[:-2], '''
    );''' ))

        buf = "".join(( buf, '''
};''' ))
        return buf

    def _get_class_superarray(self, clz: GeneratorData, def_name: str):
        '''

    // ArrayStep.NoArray
    struct SignalKey : public SignalKeyData {};

    // ArrayStep.Array
    struct SignalKey {
        using TYPE = SignalKeyData;
        std::deque<TYPE> data;
    };

    // ArrayStep.Single
    struct SignalKey;
    template <> class glz::meta<SignalKey>;

    struct SignalKey : public SignalKeyData {
        using TYPE = SignalKeyData;
        using ARRAY_TYPE = std::array<TYPE, 1>;

        friend glz::meta<SignalKey>;

        SignalKey() = default;

        private:
            explicit SignalKey(const TYPE& q) : TYPE(q) {}
            ARRAY_TYPE _internal_data;
    };
    
    '''
        
        if clz.class_type == ClassType.Enumerator:
            return ""

        if clz.array_step == ArrayStep.Array:
            return '''struct {} {{
    using TYPE = {};
    std::deque<TYPE> data;
}};'''.format(clz.name, def_name)
        elif clz.array_step == ArrayStep.Single:
            return '''struct {};
template <> struct glz::meta<{}>; 

struct {} : public {} {{ 
    using TYPE = {};
    using ARRAY_TYPE = std::array<TYPE, 1>;
    friend glz::meta<{}>;

    {}() = default;

    private:
        explicit {}(const TYPE& q) : TYPE(q) {{}}
        ARRAY_TYPE _internal_data;

}};'''.format(clz.name, 
              clz.name,
              clz.name, def_name, 
              def_name,
              clz.name,
              clz.name,
              clz.name)
        #else:
        #    return "struct {} : public {} {{}};".format(clz.name, def_name)

        return ""
    
    def _get_class_superarray_metadata(self, clz: GeneratorData, def_name: str):
        '''
        
        // ArrayStep.Single

        template <>
        struct glz::meta<SignalKey>
        {
            using T = SignalKey;
            static constexpr auto read_x = [](T& s, const T::ARRAY_TYPE& input) { s = T(input[0]); };
            static constexpr auto write_x = [](T& s) -> T::ARRAY_TYPE& { s._internal_data = T::ARRAY_TYPE{s}; return s._internal_data; };
            static constexpr auto value = object("6FrKacq7", glz::custom<read_x, write_x>);
        };

        // ArrayStep.Array

        template <>
        struct glz::meta<SignalKey>
        {
            using T = SignalKey;
            static constexpr auto value = object("6FrKacq7", &T::data);
        };
        
        '''
        if clz.class_type == ClassType.Enumerator:
            return ""
        
        #have_key = len(clz.key) > 0

        if clz.array_step == ArrayStep.Single:
            buf = '''template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto read_x = [](T& s, const T::ARRAY_TYPE& input) {{ s = T(input[0]); }};
    static constexpr auto write_x = [](T& s) -> T::ARRAY_TYPE& {{ s._internal_data = T::ARRAY_TYPE{{s}}; return s._internal_data; }};
    static constexpr auto value = '''.format(clz.name, clz.name)
    
            #if not have_key:
            buf = "".join(( buf, "glz::custom<read_x, write_x>"))
            #else:
            #    buf = "".join(( buf, "object(\"{}\", glz::custom<read_x, write_x>)".format(clz.key)))

            return "".join(( buf, ''';
};''' ))

        #elif clz.array_step == ArrayStep.Array and have_key:
        #    return '''template <>
#struct glz::meta<{}>
#{{
#    static constexpr auto value = object("{}", &T::data);
#}};'''.format(clz.name, clz.key)
        
#        elif clz.array_step == ArrayStep.NoArray and have_key:
#            return '''template <>
#struct glz::meta<{}>
#{{
#    static constexpr auto value = object("{}", [](auto& self) {{ return {}(self); }});
#}};'''.format(clz.name, clz.key, def_name)

        return ""

    def step(self, clz: GeneratorData) -> str:
        def_name = clz.name
        if clz.class_type == ClassType.Struct and clz.array_step != ArrayStep.NoArray:
            def_name = "".join(( clz.name, "Data" ))
        
        # TODO: move this code away !!
        if len(clz.key) > 0:
            self.mapped_groups.update({ clz.name: clz.key })

        return "{}\n{}\n\n{}\n{}\n\n".format(
            self._get_class(clz, def_name),
            self._get_class_metadata(clz, def_name),
            self._get_class_superarray(clz, def_name),
            self._get_class_superarray_metadata(clz, def_name)
        )

