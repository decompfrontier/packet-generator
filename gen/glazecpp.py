from datetime import datetime
from schema import *
from .generator import Generator

class GlazeGenerator(Generator):
    """This class implementes a Glaze C++ JSON compatible reader/writer.

        Each GeneratorField is parsed and converted to a relative C++ implementation.
        This class also generates all the required stubs to allow usage of such implementations.

        How the generator works?
        [
            The Glaze C++ generator works by applying custom glaze (glz::meta) metadata on the
            field to ensure the correctness of the serialization/deserializion, while preserving
            the original C++ data types for ease of use.

            The code generation is separated into two different steps of generation:
            
            The first one is to generate the class that basic class that holds the types of the JSON
            object (for example: the object that contains the SignalKey fields of an array), such basic class is called the "Data" class
            in the C++ generation. (For example: SignalKeyData contains the basic content of the Signal key)

            The second step is to generate the actual definition of the JSON object, which uses the Data
            class as either it's basic member for array types.

            For a class that is not an array, point 3 and 4 does not apply as the class can simply be
            generated as-is.

            The code generation works by doring the following:

            1. Generate the Data class, this includes the fields
            2. Generate the Glaze metadata for the data class
            3. Generate the main class, this is the holder of the array data
            4. Generate the Glaze metadata for the main class
    """

    TYPE_MAPPING: dict[type, str] = {
        int:            "uint32_t",
        intstr:         "uint32_t",
        long:           "uint64_t",
        longstr:        "uint64_t",
        str:            "std::string",
        bool:           "bool",
        intbool:        "bool",
        strbool:        "bool",
        datetimeunix:   "glzhlp::chronotime",
        datetime:       "glzhlp::chronotime",
        floatstr:       "glzhlp_float32",
        float:          "glzhlp_float32", # support for c++20 floating point
        double:         "glzhlp_float64", # support for c++20 floating point
    }
    """Mapping of Python python to C++ strings."""

    def get_start_mark(self, file_name: str) -> str:
        return """
/*
    This file was autogenerated by decompfrontier packet-generator.

    DO NOT MODIFY THIS FILE! MODIFY THE FILE {} INSIDE THE
    PACKET GENERATOR REPOSITORY AND RUN THE GENERATION AGAIN!
*/
#pragma once

#include <glaze_helpers.hpp> // c++ runtime helpers

""".format(file_name)
    
    def get_end_mark(self) -> str:
        return ""
    
    def add_import(self, imp: str) -> str:
        return """#include <{}>
""".format(imp)

    def _get_genfield_typestring(self, current_type: GeneratorField, parent: GeneratorStruct) -> str:
        """Generates the C++ type of the field.

        :param current_type: Generator field to get the C++ type from
        :param parent: Parent generator field
        :return: C++ type in string
        """

        cpp_type = ""
        if current_type.type_id in GlazeGenerator.TYPE_MAPPING: # case 1: the current type is from a mapping
            cpp_type = GlazeGenerator.TYPE_MAPPING[current_type.type_id]
        elif hasattr(current_type.type_id, "__origin__"): # case 2: the type is an annotation like dict[] or list[], this is apython specific internal field
            original_type = current_type.type_id.__origin__
            if original_type == list or original_type == commalist or original_type == atlist:
                contained_python_type = current_type.type_id.__args__[0] # argument of the list
                contained_cpp_type = self._get_genfield_typestring(GeneratorField(type_id = contained_python_type), parent) # call this function again for generating the argument
                cpp_type = "std::vector<{}>".format(contained_cpp_type)
            else:
                raise ValueError("Unsupported Python origin-type: {}".format(original_type))
        else: # if it's not a python builtin type, threat this as a custom type
            cpp_type = current_type.type_id.__name__
        
        if current_type.default_action == DefaultType.Omit:
            cpp_type = "std::optional<{}>".format(cpp_type) # append the optional<> to allow glaze to skip types that should be omitted if null
        
        return cpp_type

    def _get_genfield_declaration(self, current_field: GeneratorField, parent: GeneratorStruct) -> str:
        """Generates the field declaration.

        Example: std::string key{};

        :param current_field: Field to generate
        :param parent: Parent of the field
        :return: String that contains the declaration
        """

        if parent.class_type == ClassType.Enumerator: # the container of this field is an enumerator?
            if issubclass(type(current_field.type_id), Enum): # is this a normal enumerator?
                # Example: MY_ENUM_FIELD_1 = 4,
                return "{} = {},".format(current_field.name, current_field.type_id.value)
            elif issubclass(type(current_field.type_id), Flag): # is this a flag enumerator? (bitwise flag enumerator)
                # Example: MY_ENUM_FIELD_1 = 1 << 1,
                return "{} = 1 << {},".format(current_field.name, current_field.type_id.value)
            else:
                raise Exception("Unsupported field in enumerator: {}".format(current_field))
        elif parent.class_type == ClassType.EnumeratorString: # the container of this field is an enumerator that maps into a string?
            if issubclass(type(current_field.type_id), Enum): # is this a normal enumerator?
                return "constexpr const auto {} = \"{}\";".format(current_field.name, current_field.type_id.value) # In C++ there are no string enumerators, therefore we assign them as constant strings
            else:
                raise Exception("Unsupported field in enumerator string: {}".format(current_field))
        else: # is the type any other thing, like a normal field of a structure?
            # Example: uint32_t  my_field{};
            string_type = self._get_genfield_typestring(current_field, parent)
            return "{}\t{}{{}};".format(string_type, current_field.name)

    def _get_glazecpp_field_metadata(self, current_field: GeneratorField, parent: GeneratorStruct) -> str:
        """Generates the glaze c++ metadata mapping for a field.

        Example:
            "Kn51uR4Y", glz::quoted<&T::key>,

        :param current_field: Field to generate
        :param parent: Parent of the field
        :return: C++ glaze metadata generated
        """

        glaze_metadata_type = ""

        cpp_parent_name = parent.name
        if parent.array_step != ArrayStep.NoArray:
            cpp_parent_name = "".join((cpp_parent_name, "Data")) # a JSON array adds "Data" at the end to specify the single field

        if current_field.type_id == str and current_field.quoted: # this is a string that should be escaped (like a MySQL string)
            # Ex: glz::quoted<&T::myField>
            glaze_metadata_type = "glz::quoted<&T::{}>".format(current_field.name)
        elif current_field.type_id == float: # We use a custom glaze mapping for C++20 float32/float64 support
            glaze_metadata_type = "glzhlp_write_float32(&T::{})".format(current_field.name)
        elif current_field.type_id == double:
            glaze_metadata_type = "glzhlp_write_float64(&T::{})".format(current_field.name)
        elif current_field.type_id == intbool: # boolean that should be converted to an integer (and not a JSON boolean)
            # Ex: glz::bools_as_numbers<&T::myField>
            glaze_metadata_type = "glz::bools_as_numbers<&T::{}>".format(current_field.name)
        elif current_field.type_id == strbool: # a boolean that should be converted to a string
            # Ex: glz::strbool<&T::myField>
            glaze_metadata_type = "glzhlp::strbool<{}, &T::{}>".format(cpp_parent_name, current_field.name)
        elif current_field.type_id == intstr or current_field.type_id == floatstr or current_field.type_id == longstr:
            glaze_metadata_type = "glz::quoted_num<&T::{}>".format(current_field.name)
        elif current_field.type_id == datetimeunix: # a datetime expressed in UNIX timestamp (long)
            # Ex: glzhlp::datetimeunix<&T::myField>
            glaze_metadata_type = "glzhlp::datetimeunix<{}, &T::{}>".format(cpp_parent_name, current_field.name)
        elif current_field.type_id == datetime: # a datetime expressed in string
            # Ex: glzhlp::datetime<&T::myField>
            glaze_metadata_type = "glzhlp::datetime<{}, &T::{}>".format(cpp_parent_name, current_field.name)
        elif hasattr(current_field.type_id, "__origin__"):
            original_type = current_field.type_id.__origin__
            if original_type == commalist:
                glaze_metadata_type = "glzhlp::stringlist<{}, &T::{}, ','>".format(cpp_parent_name, current_field.name)
            elif original_type == atlist:
                glaze_metadata_type = "glzhlp::stringlist<{}, &T::{}, '@'>".format(cpp_parent_name, current_field.name)
            else: # any other type that theorically doesn't require a mapping, we just use the default one
                glaze_metadata_type = "&T::{}".format(current_field.name)
        else: # any other type that doesn't require a mapping
            # Ex: &T::myField
            glaze_metadata_type = "&T::{}".format(current_field.name)
        
        glaze_key_name = current_field.key

        """
            Some fields might not have a key group as it uses the keygroup of the
            specified class itself (for example GmeAction).

            To account for this data, we fetch the key_group field from the associated
            type, this can help when adding custom fields that uses keyjson types.
        """
        if len(current_field.key) < 1:
            if not hasattr(current_field.type_id, "__ir_key_group__"):
                raise ValueError("The specified type {} does not have a key_group. Are you sure the specification is correct?".format(current_field.type_id.__name__))

            glaze_key_name = getattr(current_field.type_id, "__ir_key_group__")

        # "key": "glaze mapper", example: "a3vSYuq2", &T::body, 
        return "\"{}\", {},".format(glaze_key_name, glaze_metadata_type)
    
    def _get_classtype_name(self, type: ClassType) -> str:
        """
        Gets the C++ name delcaration of the class type.

        :param type: Class type
        :return: C++ class type
        """
        match type:
            case ClassType.Struct:
                return "struct"
            case ClassType.Enumerator:
                return "enum class"
            case ClassType.EnumeratorString:
                return "namespace"
            case _:
                raise Exception("Unsupported class type: {}".format(str(type)))

    def _get_cpp_class_definition(self, struct: GeneratorStruct, cpp_type_name: str) -> str:
        """Generates the C++ class definition.

        :param struct: Structure to generate
        :param cpp_type_name: Typename of the structure for C++
        :return: Generated C++ class type
        """

        if struct.class_type == ClassType.EnumeratorString:
            # because C++ does not have enum string, the idea
            # is that we generate the structure as a namespace
            # (this allows us to avoid conflicts with the fields name)
            # and generate a special ""structure type"" that maps to std::string
            # so this mimics the generation of a real class type.
            cpp_output = """using {} = std::string;

namespace v_{} {{
""".format(cpp_type_name, cpp_type_name)
        else: # this is a normal c++ type (either enum, enum class or class)
            # Example: class MyData {\n
            cpp_output = """{} {} {{
""".format(self._get_classtype_name(struct.class_type), cpp_type_name)

        for field in struct.fields: # iterate all fields in the structure and generate them
            # Example:      uint32_t field;
            cpp_output = "".join((cpp_output, "\t", self._get_genfield_declaration(field, struct), "\n"))
        
        # };
        return "".join((cpp_output, "};"))
    
    def _get_glaze_cpp_metadata(self, struct: GeneratorStruct, cpp_type_name: str) -> str:
        """Generates the Glaze C++ explicit metadata (struct glz::meta).
        
        Generation example for classes with "ArrayStep.NoArray":
        
            template <>
            struct glz::meta<SignalKey>
            {
                static constexpr auto value = object(
                    "6FrKacq7", object (
                        "Kn51uR4Y", glz::quoted<&T::key>
                    )
                )
            }

        Generation example for other classes:
            
            template <>
            struct glz::meta<SignalKeyData>
            {
                using T = SignalKeyData;
                static constexpr auto value = object(
                    "Kn51uR4Y", glz::quoted<&T::key>
                );
            };

        :param struct: Structure to generate
        :param cpp_type_name: Typename of the structure for C++
        :return: Generated C++ glaze metadata mapping
        """

        if struct.class_type != ClassType.Struct:
            return "" # do not make any metadata for enumerators

        """ Example:
            template <>
            struct glz::name<MyData>
            {
                using T = MyData;
                static constexpr auto value = object(
                
        """

        # metadata start
        cpp_output = """template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto value = object(
""".format(cpp_type_name, cpp_type_name)

        for field in struct.fields: # iterate and generate all the metadatas
            #       &T::myField,
            cpp_output = "".join((cpp_output, "\t\t", self._get_glazecpp_field_metadata(field, struct), "\n"))
        
        # remove the final ",\n" as this is the end and append the metadata field end
        cpp_output = "".join(( cpp_output[:-2], """
    );""" ))

        # append the metadata end
        cpp_output = "".join(( cpp_output, """
};""" ))
        return cpp_output

    def _get_class_array_container(self, struct: GeneratorStruct, cpp_type_name: str):
        """This function generates the array container of a JSON field/group that is an array.

        In case the function is not an array, simply define an alias of the Data element (the single field container)
        as the basic type.

        Output code if the class is an array:
            struct SignalKey {
                using TYPE = SignalKeyData;
                std::deque<TYPE> data;
            };

        Output code if the class is an array with a single element:
            struct SignalKey;
            template <> class glz::meta<SignalKey>;

            struct SignalKey : public SignalKeyData {
                using TYPE = SignalKeyData;
                using ARRAY_TYPE = std::array<TYPE, 1>;

                friend glz::meta<SignalKey>;

                SignalKey() = default;

                private:
                    explicit SignalKey(const TYPE& q) : TYPE(q) {}
                    ARRAY_TYPE _internal_data;
            };

            :param struct: Structure to generate
            :param cpp_type_name: Typename of the structure for C++
            :return: Output C++ type
        """
        
        if struct.class_type != ClassType.Struct:
            return "" # enumerators cannot be arrays!

        cpp_output = ""
        if struct.array_step == ArrayStep.Array: # the type is a simple array
            cpp_output = '''struct {} {{
    using TYPE = {};
    std::deque<TYPE> data;
}};'''.format(struct.name, cpp_type_name)
        elif struct.array_step == ArrayStep.Single: # Array of a single element, create a fixed array with one element and relative stubs to use it
            cpp_output = '''struct {};
template <> struct glz::meta<{}>; 

struct {} : public {} {{ 
    using TYPE = {};
    using ARRAY_TYPE = std::array<TYPE, 1>;
    friend glz::meta<{}>;

    {}() = default;

    private:
        explicit {}(const TYPE& q) : TYPE(q) {{}}
        ARRAY_TYPE _internal_data;

}};'''.format(struct.name,  # struct ...
              struct.name, # glz::meta<...>
              struct.name, cpp_type_name, # struct ...Data, public ...
              cpp_type_name, # TYPE = ...Data
              struct.name, # meta<...>
              struct.name, # constructor
              struct.name # explicit constructor
            )

        return cpp_output
    
    def _get_class_superarray_metadata(self, field: GeneratorStruct, cpp_type_name: str):
        """This function generates the array container of a JSON field/group that is an array.

        Output code if the class is an array:
            template <>
            struct glz::meta<SignalKey>
            {
                using T = SignalKey;
                static constexpr auto value = object("6FrKacq7", &T::data);
            };

        Output code if the class is an array with a single element:
            template <>
            struct glz::meta<SignalKey>
            {
                using T = SignalKey;
                static constexpr auto read_x = [](T& s, const T::ARRAY_TYPE& input) { s = T(input[0]); };
                static constexpr auto write_x = [](T& s) -> T::ARRAY_TYPE& { s._internal_data = T::ARRAY_TYPE{s}; return s._internal_data; };
                static constexpr auto value = object("6FrKacq7", glz::custom<read_x, write_x>);
            };

            :param struct: Structure to generate
            :param cpp_type_name: Typename of the structure for C++
            :return: Output C++ type
        """

        if field.class_type != ClassType.Struct:
            return "" # enumerators cannot be arrays!

        if field.array_step == ArrayStep.Single: # array with one element, generate an explicit mapping to force the map of one element only
            cpp_output = '''template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto read_x = [](T& s, const T::ARRAY_TYPE& input) {{ s = T(input[0]); }};
    static constexpr auto write_x = [](T& s) -> T::ARRAY_TYPE& {{ s._internal_data = T::ARRAY_TYPE{{s}}; return s._internal_data; }};
    static constexpr auto value = '''.format(field.name, field.name)
            
            cpp_output = "".join(( cpp_output, "glz::custom<read_x, write_x>")) # set the custom mapping functions to glaze
            # close definition
            cpp_output = "".join(( cpp_output, ''';
};''' ))

        elif field.array_step == ArrayStep.Array: # normal array
            cpp_output = '''template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto value = object("{}", &T::data);
}};'''.format(field.name, field.name, field.key)
        else:
            cpp_output = ""

        return cpp_output

    def step(self, struct: GeneratorStruct) -> str:
        cpp_struct_name = struct.name
        if struct.class_type == ClassType.Struct and struct.array_step != ArrayStep.NoArray:
            cpp_struct_name = "".join(( cpp_struct_name, "Data" )) # we append "Data" so we make sure we have a base structure type (StructData) and an structure that contains the array to the data (Struct)

        # call the various generation steps
        return "{}\n{}\n\n{}\n{}\n\n".format(
            # C++ class definition (struct bla bla)
            self._get_cpp_class_definition(struct, cpp_struct_name),
            # Glaze c++ metadata definition (mapping of the JSON keys and how the fields should be converted for glaze)
            self._get_glaze_cpp_metadata(struct, cpp_struct_name),
            # C++ array container (struct bla bla NOT DATA)
            self._get_class_array_container(struct, cpp_struct_name),
            # Glaze c++ metadata of the C++ container
            self._get_class_superarray_metadata(struct, cpp_struct_name)
        )


    def get_extension(self) -> str:
        return ".hpp"
