from datetime import datetime
from schema import *
from .generator import Generator

class GlazeGenerator(Generator):
    """This class implementes a Glaze C++ JSON compatible reader/writer.

        Each GeneratorField is parsed and converted to a relative C++ implementation.
        This class also generates all the required stubs to allow usage of such implementations.

        How the generator works?
        [
            The Glaze C++ generator works by applying custom glaze (glz::meta) metadata on the
            field to ensure the correctness of the serialization/deserializion, while preserving
            the original C++ data types for ease of use.

            The code generation is separated into two different steps of generation:
            
            The first one is to generate the class that basic class that holds the types of the JSON
            object (for example: the object that contains the SignalKey fields of an array), such basic class is called the "Data" class
            in the C++ generation. (For example: SignalKeyData contains the basic content of the Signal key)

            The second step is to generate the actual definition of the JSON object, which uses the Data
            class as either it's basic member for array types.

            For a class that is not an array, point 3 and 4 does not apply as the class can simply be
            generated as-is.

            The code generation works by doring the following:

            1. Generate the Data class, this includes the fields
            2. Generate the Glaze metadata for the data class
            3. Generate the main class, this is the holder of the array data
            4. Generate the Glaze metadata for the main class
    """

    TYPE_MAPPING: dict[type, str] = {
        int:            "uint32_t",
        long:           "uint64_t",
        str:            "std::string",
        bool:           "bool",
        intbool:        "bool",
        strbool:        "bool",
        datetimeunix:   "glzhlp::chronotime",
        datetime:       "glzhlp::chronotime",
        float:          "glzhlp_float32",
        double:         "glzhlp_float64",
    }
    """Mapping of Python python to C++ strings."""

    def get_start_mark(self, file_name: str) -> str:
        return """
/*
    This file was autogenerated by decompfrontier packet-generator.

    DO NOT MODIFY THIS FILE! MODIFY THE FILE {} INSIDE THE
    PACKET GENERATOR REPOSITORY AND RUN THE GENERATION AGAIN!
*/
#pragma once

#include <glaze_helpers.hpp> // c++ runtime helpers

""".format(file_name)
    
    def get_end_mark(self) -> str:
        return ""
    
    def add_import(self, imp: str) -> str:
        return """#include <{}>
""".format(imp)

    def _get_genfield_typestring(self, t: GeneratorField, parent: GeneratorData) -> str:
        """Generates the C++ type of the field.

        :param t: Generator field to get the C++ type from
        :param parent: Parent generator field
        :return: C++ type in string
        """
        #if parent.class_type == ClassType.EnumeratorString:
        #    return "std::string"
        
        strtype = ""
        if t.type_id in GlazeGenerator.TYPE_MAPPING:
            strtype = GlazeGenerator.TYPE_MAPPING[t.type_id]
        elif hasattr(t.type_id, "__origin__"):
            orig = t.type_id.__origin__
            if orig == list:
                argtype = t.type_id.__args__[0]
                argstr = self._get_genfield_typestring(GeneratorField(type_id = argtype), parent)
                strtype = "std::vector<{}>".format(argstr)
            else:
                raise ValueError("Unsupported args type: {}".format(orig))
        else:
            strtype = t.type_id.__name__
        
        if t.default_action == DefaultType.Omit:
            return "std::optional<{}>".format(strtype)
        
        return strtype

    def _get_genfield_declaration(self, clz: GeneratorField, parent: GeneratorData) -> str:
        """Generates the field declaration.

        Example: std::string key{};

        :param clz: Field to generate
        :param parent: Parent field
        :return: String that contains the declaration
        """

        if parent.class_type == ClassType.Enumerator:
            if issubclass(type(clz.type_id), Enum):
                # Example: MY_ENUM_FIELD_1 = 4,
                return "{} = {},".format(clz.name, clz.type_id.value)
            elif issubclass(type(clz.type_id), Flag):
                return "{} = 1 << {},".format(clz.name, clz.type_id.value)
            else:
                raise Exception("Something wrong?")
        elif parent.class_type == ClassType.EnumeratorString:
            if issubclass(type(clz.type_id), Enum):
                return "constexpr const auto {} = \"{}\";".format(clz.name, clz.type_id.value)
            else:
                raise Exception("Something wrong?")
        
        string_type = self._get_genfield_typestring(clz, parent)
        # Example: uint32_t  my_field{};
        return "{}\t{}{{}};".format(string_type, clz.name)

    def _get_glazecpp_field_metadata(self, f: GeneratorField) -> str:
        """Generates the glaze c++ metadata mapping for a field.

        Example:
            "Kn51uR4Y", glz::quoted<&T::key>,

        :param f: Field to generate
        :return: C++ glaze metadata generated
        """

        glazemt = ""

        if f.type_id == str and f.quoted:
            # Ex: glz::quoted<&T::myField>
            glazemt = "glz::quoted<&T::{}>".format(f.name)
        elif f.type_id == float:
            glazemt = "glzhlp_write_float32(&T::{})".format(f.name)
        elif f.type_id == double:
            glazemt = "glzhlp_write_float64(&T::{})".format(f.name)
        elif f.type_id == intbool:
            # Ex: glz::bools_as_numbers<&T::myField>
            glazemt = "glz::bools_as_numbers<&T::{}>".format(f.name)
        elif f.type_id == strbool:
            # Ex: glz::strbool<&T::myField>
            glazemt = "glzhlp::strbool<&T::{}>".format(f.name)
        elif f.type_id == datetimeunix:
            # Ex: glzhlp::datetimeunix<&T::myField>
            glazemt = "glzhlp::datetimeunix<&T::{}>".format(f.name, f.name)
        elif f.type_id == datetime:
            # Ex: glzhlp::datetime<&T::myField>
            glazemt = "glzhlp::datetime<&T::{}>".format(f.name, f.name)
        else:
            # Ex: &T::myField
            glazemt = "&T::{}".format(f.name)
        
        glazekey = f.key

        """
            Some fields might not have a key group as it uses the keygroup of the
            specified class itself (for example GmeAction).

            To account for this data, we fetch the key_group field from the associated
            type, this can help when adding custom fields that uses keyjson types.
        """
        if len(f.key) < 1:
            if not hasattr(f.type_id, "key_group"):
                raise ValueError("The specified type {} does not have a key_group. Are you sure the specification is correct?".format(f.type_id.__name__))

            glazekey = getattr(f.type_id, "key_group")

        # "key": "glaze mapper", example: "a3vSYuq2", &T::body, 
        return "\"{}\", {},".format(glazekey, glazemt)
    
    def _get_classtype_name(self, type: ClassType) -> str:
        """
        Gets the C++ name delcaration of the class type.

        :param type: Class type
        :return: C++ class type
        """
        match type:
            case ClassType.Struct:
                return "struct"
            case ClassType.Enumerator:
                return "enum class"
            case ClassType.EnumeratorString:
                return "namespace"
            case _:
                raise Exception("Unsupported class type: {}".format(str(type)))

    def _get_cpp_class_definition(self, clz: GeneratorData, def_name: str) -> str:
        """Generates the C++ class definition.

        :param clz: Class to generate
        :param def_name: C++ class name
        :return: Generated C++ class type
        """

        if clz.class_type == ClassType.EnumeratorString:
            # because C++ does not have enum string, the idea
            # is that we generate a namespace and a using type
            buf = """using {} = std::string;

namespace v_{} {{
""".format(def_name, def_name)
        else:
            # Example: class MyData {\n
            buf = """{} {} {{
""".format(self._get_classtype_name(clz.class_type), def_name)

        for field in clz.fields:
            # Example:      uint32_t field;
            buf = "".join((buf, "\t", self._get_genfield_declaration(field, clz), "\n"))
        
        # };
        return "".join((buf, "};"))
    
    def _get_glaze_cpp_metadata(self, clz: GeneratorData, def_name: str) -> str:
        """Generates the Glaze C++ explicit metadata (struct glz::meta).
        
        Generation example for classes with "ArrayStep.NoArray":
        
            template <>
            struct glz::meta<SignalKey>
            {
                static constexpr auto value = object(
                    "6FrKacq7", object (
                        "Kn51uR4Y", glz::quoted<&T::key>
                    )
                )
            }

        Generation example for other classes:
            
            template <>
            struct glz::meta<SignalKeyData>
            {
                using T = SignalKeyData;
                static constexpr auto value = object(
                    "Kn51uR4Y", glz::quoted<&T::key>
                );
            };

        :param clz: Class to generate
        :param def_name: C++ class name
        :return: C++ metadata string
        """

        if clz.class_type != ClassType.Struct:
            return "" # do not make any metadata for structures

        """ Example:
            template <>
            struct glz::name<MyData>
            {
                using T = MyData;
                static constexpr auto value = object(
                
        """

        buf = """template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto value = object(
""".format(def_name, def_name)

        for field in clz.fields:
            #       &T::myField,
            buf = "".join((buf, "\t\t", self._get_glazecpp_field_metadata(field), "\n"))
        
        buf = "".join(( buf[:-2], """
    );""" ))

        buf = "".join(( buf, """
};""" ))
        return buf

    def _get_class_array_container(self, clz: GeneratorData, def_name: str):
        """This function generates the array container of a JSON field/group that is an array.

        In case the function is not an array, simply define an alias of the Data element (the single field container)
        as the basic type.

        Output code if the class is an array:
            struct SignalKey {
                using TYPE = SignalKeyData;
                std::deque<TYPE> data;
            };

        Output code if the class is an array with a single element:
            struct SignalKey;
            template <> class glz::meta<SignalKey>;

            struct SignalKey : public SignalKeyData {
                using TYPE = SignalKeyData;
                using ARRAY_TYPE = std::array<TYPE, 1>;

                friend glz::meta<SignalKey>;

                SignalKey() = default;

                private:
                    explicit SignalKey(const TYPE& q) : TYPE(q) {}
                    ARRAY_TYPE _internal_data;
            };

            :param clz: Class to generate
            :param def_name: C++ class name
            :return: Output C++ type
        """
        
        if clz.class_type != ClassType.Struct:
            return ""

        if clz.array_step == ArrayStep.Array:
            # Simple array that should be mapped
            return '''struct {} {{
    using TYPE = {};
    std::deque<TYPE> data;
}};'''.format(clz.name, def_name)
        elif clz.array_step == ArrayStep.Single:
            # Array of a single element, create a fixed array with one element and relative stubs to use it
            return '''struct {};
template <> struct glz::meta<{}>; 

struct {} : public {} {{ 
    using TYPE = {};
    using ARRAY_TYPE = std::array<TYPE, 1>;
    friend glz::meta<{}>;

    {}() = default;

    private:
        explicit {}(const TYPE& q) : TYPE(q) {{}}
        ARRAY_TYPE _internal_data;

}};'''.format(clz.name, 
              clz.name,
              clz.name, def_name, 
              def_name,
              clz.name,
              clz.name,
              clz.name)

        return ""
    
    def _get_class_superarray_metadata(self, clz: GeneratorData, def_name: str):
        """This function generates the array container of a JSON field/group that is an array.

        Output code if the class is an array:
            template <>
            struct glz::meta<SignalKey>
            {
                using T = SignalKey;
                static constexpr auto value = object("6FrKacq7", &T::data);
            };

        Output code if the class is an array with a single element:
            template <>
            struct glz::meta<SignalKey>
            {
                using T = SignalKey;
                static constexpr auto read_x = [](T& s, const T::ARRAY_TYPE& input) { s = T(input[0]); };
                static constexpr auto write_x = [](T& s) -> T::ARRAY_TYPE& { s._internal_data = T::ARRAY_TYPE{s}; return s._internal_data; };
                static constexpr auto value = object("6FrKacq7", glz::custom<read_x, write_x>);
            };

            :param clz: Class to generate
            :param def_name: C++ class name
            :return: Output C++ type
        """

        if clz.class_type != ClassType.Struct:
            return ""

        if clz.array_step == ArrayStep.Single:
            buf = '''template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto read_x = [](T& s, const T::ARRAY_TYPE& input) {{ s = T(input[0]); }};
    static constexpr auto write_x = [](T& s) -> T::ARRAY_TYPE& {{ s._internal_data = T::ARRAY_TYPE{{s}}; return s._internal_data; }};
    static constexpr auto value = '''.format(clz.name, clz.name)
    
            buf = "".join(( buf, "glz::custom<read_x, write_x>"))

            return "".join(( buf, ''';
};''' ))

        elif clz.array_step == ArrayStep.Array:
            return '''template <>
struct glz::meta<{}>
{{
    using T = {};
    static constexpr auto value = object("{}", &T::data);
}};'''.format(clz.name, clz.name, clz.key)

        return ""

    def step(self, clz: GeneratorData) -> str:
        def_name = clz.name
        if clz.class_type == ClassType.Struct and clz.array_step != ArrayStep.NoArray:
            def_name = "".join(( clz.name, "Data" ))

        return "{}\n{}\n\n{}\n{}\n\n".format(
            # C++ class definition (struct bla bla)
            self._get_cpp_class_definition(clz, def_name),
            # Glaze c++ metadata definition (mapping of the JSON keys and how the fields should be converted for glaze)
            self._get_glaze_cpp_metadata(clz, def_name),

            self._get_class_array_container(clz, def_name),
            self._get_class_superarray_metadata(clz, def_name)
        )


    def get_extension(self) -> str:
        return ".hpp"
